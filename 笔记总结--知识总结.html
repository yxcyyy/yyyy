<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>知识总结</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="笔记总结.html">笔记总结</a></p>

<ol>
<li><a href="笔记总结--知识总结.html">知识总结</a></li>
</ol></div>
<div class="page"><h1><b><u>知识总结</u></b></h1><br />▸ <a href="笔记总结.html">笔记总结</a><br />  • <a href="笔记总结.html#h1-1">首页总结</a><br />  ▸ <a href="笔记总结--知识总结.html">知识总结</a><br />    • <a href="笔记总结--知识总结.html#h1-1">1.安装java环境</a><br />    • <a href="笔记总结--知识总结.html#h1-2">2.基础知识</a><br />      ◇ <a href="笔记总结--知识总结.html#h2-1">运算符</a><br />      ◇ <a href="笔记总结--知识总结.html#h2-2">流程控制语句</a><br />    • <a href="笔记总结--知识总结.html#h1-3">第五天</a><br /><br /><br /><br /><br /><a name="h1-1"></a><h1>1.安装java环境</h1><br /><br />一些快捷方式: cd  打开某个文件    cd.. 返回上一层目录   cls:清屏<br /><br />程序能够实现跨平台吗?<br />在各个平台上都有对应的JVM(java 虚拟机)<br /><br />JVM:java虚拟机,只要装了它,Java程序就可以运行<br />JRE:包括JVM和需要的核心类库,如果只是运行程序,装JRE即可<br />JDK:包括开发环境所有的工具和JRE<br /><br />总结:只要装JDK即可<br /><br />配置环境变量:更加简单的运行JDK.exe文件<br /><br />在我的电脑-高级系统设置-环境变量-系统变量栏选择path,添加路径<br /><br />安装的软件:editPlus   ,jdk   eclipse    myeclipse<br /><br />开始跑一个程序<br />&gt;编译   使用javac.exe命令  编译.class(字节码文件)<br />&gt;运行   使用java.exe 命令 <br /><br /><br /><a name="h1-2"></a><h1>2.基础知识</h1><br />关键字:被java赋予了特殊含义的单词   public   static  float   private<br />标识符:程序中需要我们自己命名的---命名规则<br /><br />注释符:单行注释  //<br />多行注释:  <br /><br />/*<br />*<br />*/<br /><br />常量:固定不变的量---字符串常量,小数常量,整数常量<br /><br />进制转换:<br />二进制   八进制    十进制     十六进制 <br />规则:二进制:满二进一   后面的一样<br /><br />1byte=8bit<br />1kb = 1024b<br />1mb = 1024kb<br />1Gb = 1024mb<br />1Tb = 1024Gb<br />1Pb = 1024Tb<br /><br />转换<br />二进制转十进制<br /><br />十进制转二进制<br /><br />负数的二进制:正数的二进制取反加一<br /><br />一个字节的范围  -128----127<br /><br />10000000  128<br />01111111<br />00000001<br />10000000 -128   <br />  <br />变量:存储程序中用到的数据,每个变量只能存储一个数,变量中的数是可以改变的<br /><br />数据类型:决定了变量占据多大的空间<br /><br />分类:<br /><br />基本数据类型<br /><br />数值型:<br />&gt;整型:byte   -128---127<br />short    -(2^15+1)----2^15<br />int  4个字节<br />long  8个<br />&gt;浮点型<br />float 单浮点型   4<br />double 双浮点型  8<br /><br />&gt;布尔型<br />boolean   1<br /><br />&gt;字符型<br />char <br /><br />编码:将 字符转成对应的数的过程   ,计算机只识别二进制数<br />Unicode     a-97    A-65   0-48<br />常见的编码格式:美国标准:ASCII   国标:gbk   gb2312    欧洲:ISO8859-1    通用性:utf-8<br /><br />自动类型转化,强制类型转化<br />等级高低:byte,short,char-int-long-float-double<br /><br />强制类型转换:<br />byte m = 11;<br />m = (byte)m+10;<br />00000000 00000000 00000000 00001010<br />00000000 00000000 00000000 00001011<br />00000000 00000000 00000000 00010101<br />00010101<br /><br />//转义字符:通过反斜杠改变后面字符的含义<br /><br />\n   \t  <br />换行符:windows  \r\n       linux,Unix  :\n<br /><br /><br /><br />引用数据类型<br />&gt;数组<br />&gt;类<br />&gt;接口<br /><br /><br /><a name="h2-1"></a><h2>运算符</h2><br /><br />运算符分类1:<br />单目运算符:<br />双目运算符<br />三目运算符<br /><br />分类2:<br />1.算数运算符   + - * / %  ++  --(计算负数时,结果的符号跟前面的数保持一致)<br />2.赋值运算符   = += -= *= /= <br />3.关系运算符   &gt; &gt;=  &lt;  &lt;= !=<br />4.逻辑运算符  !  &amp;&amp;  ||---短路与,短路或<br />5.位运算符  ^  |   &amp;   ~    -----求两个数相加   <br />               <br />               /*<br />		|:按位或，两个数同一二进制位，有一个为1，结果就是1<br />                &amp;（按位与），两个数同一二进制位，都为1，结果才是1，否则为0<br />		^（按位异或）：两个数同一二进制位，相异时，结果为1，相同时，为0<br />		~（非）：按位取反<br /><br />		 ①用按位与运算将特定位清0或保留特定位；<br />		 ②用按位或运算将特定的位置设置为1；<br />		 ③用按位异或运算将某个变量的特定位翻转或交换两个变量的值。<br /><br />		 */<br />6.移位运算符 &gt;&gt;  &lt;&lt;   &gt;&gt;&gt;   &lt;&lt;&lt;<br /><br />运算时注意点:运算符的优先级,运算符运算的方向<br /><br /><br /><a name="h2-2"></a><h2>流程控制语句</h2><br /><br />分支语句<br />if<br />if  else{if  else }<br />if  elseif else<br /><br />switch  case<br />原理：首先判断条件表达式的值，如果跟值1相同，就执行语句1，遇到了break,结束当前的switch，直接跳到}，同理跟值2相同，。。。。。<br />		如果条件表达式确定的值经过比较与所有的case都不相同，执行defaulit：后面的语句，遇到break，结束。<br />		<br />		注意：1.条件表达式：通过他得到的是一个值<br />		2.break：程序遇到break，会直接跳出switch{}，结束程序<br />		3.如果某一个case：后面没有break，当程序执行了这个case之后，后直接执行挨着的case<br />		4.可以作为条件表达式的类型  int,byte,short,char,枚举（jdk1.5），字符串（jdk1.7）<br />		*/<br /><br />例子://3,4,5 春季 6,7,8 夏季  9,10,11 秋季 12, 1, 2 冬季<br /><br />循环控制语句<br /><br /><br />do while --先将语句执行一遍<br />while<br /><br />//例题：取出k=5的数<br /><br />for<br /><br />三目运算符  ?:<br /><br />int a = 5;<br />int b = 6;<br />int c = a&lt;b?a:b;<br /><br /><br />嵌套循环<br /><br />打印矩形星星<br />/*<br /><br />*<br />**<br />***<br />****<br />*****<br /><br />*/<br /><br />1<br />12<br />123<br />1234<br />12345<br /><br /><br /><br />九九乘法表<br />1*1=1<br />1*2=2 2*2=4<br />1*3=3 2*3=6 3*3=9<br /><br /><br />*/<br /><br />/*<br />打印一个实心菱形图案<br />   *<br />  ***<br /> *****<br />*******<br /> *****<br />  ***<br />   *<br /><br />*/<br /><br />/*3.打印一个空心菱形图案<br />  问题：用*号打印一个如下的空心菱形图案 ：<br /><br />                   *<br />                  * *<br />                 *   *<br />                *     *<br />                 *   *<br />                  * *<br />                   *<br /><br />*/<br /><br />//编写一个程序，最多接收10个数，求这些数的和，<br />        //用户可以通过输入999终止程序，并显示输入数的和<br /><br /><br />//打印结果：0101010101  说明了break的作用<br /><br />//打印结果：013013013013013  说明了continue的作用<br /><br />//m  n  0101010101  说明了break的作用<br /><br />函数:是具有某种特定功能的一段代码块儿<br />构成<br /><br />返回值类型  函数名(参数类型 形式参数1,参数类型 形式参数2...){<br />	执行语句;<br />	return 返回值;<br />}<br /><br />函数的作用:简化代码,提高代码的复用性,提高安全性,操作性<br /><br />具体讲解函数<br /><br />函数的内存表现<br /><br />Java在运行的时候,将内存分成堆区,栈区,方法区,本地方法区,寄存器<br />栈区:存储数据时先进后出,存放的的局部变量,使用完系统立即回收内存<br />堆区:存储的是实体(对象,数组),可以存放多个数据,在堆区中变量如果没有赋值,系统默认赋值成0<br />当引用被赋值成null时,数组会通过垃圾回收机制进行回收内存,控制垃圾回收的是一个线程,线程的级别较低,不会立即释放内存<br /><br /><br />重载<br /><br /><br />数组:<br />	//数组：存储多个数据<br />		//特点：是一种数据类型，一种引用数据类型，存储多个数据的时候使用<br /><br />		//数组的内存是连续的，数组中没有赋值的元素会默认赋值成0<br /><br />		//创建一个数组存储5个数<br />		//创建的一个数组：  new + 基本数据类型[当前数组要表示的数的最大个数] <br />		//数组类型的构成：基本数据类型[]<br />		//铜鼓new创建的数组在堆区<br />		<br />		int[] arr = new int[5];<br /><br />		arr[0] = 5;<br /><br />		画内存图<br /><br />	多种创建方式<br /><br />	数组越界<br /><br />	求最大值<br /><br />	二维数组<br /><br />排序<br />交换排序<br />冒泡排序<br /><br />查找<br />二分查找<br /><br />第四天<br /><br />类-面向对象的理解<br />/*<br /> * 当一个文件中存在多个类时,main函数在哪里,程序就会先执行哪个类<br /> * 一个文件中只允许有一个main函数<br /> * 当前文件的名字最好与main函数所在的类名保持一致<br /> * <br /> * 类:是一种引用数据类型<br /> * <br /> */<br /><br />/*<br /> * 类的关键字是class<br /> * 创建类的三要素<br /> *名字：遵守驼峰原则，所有单词的首字母大写<br />属性：遵守驼峰原则，但是第一个单词的首字母小写，其他的首字母大写<br />行为：遵守驼峰原则，但是第一个单词的首字母小写，其他的首字母大写<br /> * <br /> * 设计类:---人<br /> * 名字(类名):Person<br /> * 属性:height,age<br /> * 行为:run,fight<br /> * <br /> * 成员方法分类:<br /> * 类方法:由static进行修饰,在调用的时候要由类名调用--内部不能使用非静态成员变量<br /> * 对象方法:在调用的时候要由对象调用<br /> * <br /> * 总结:大部分时间使用类方法,不需要创建对象,当方法中必须使用非静态成员变量的时候,使用对象方<br /> * <br /> * <br /> * 成员变量与局部变量的区别:<br /> * 1.作用域:局部变量作用域从定义到当前的函数结束,成员变量是当前的类<br /> * 2.存储位置:栈区,成员变量堆区<br /> * 3.释放机制:立刻释放,成员变量随着对象的释放而释放<br /> * 4.默认值:必须给默认值,成员变量,默认值为0,对象为null<br /> */<br /><br />构造方法<br />	//构造方法介绍--用于创建对象及初始化成员变量,可以不创建,系统会通过new调用默认的不带参数的构造方法创建对象,<br />	//如果自己创建了构造方法,就不会再调用系统的<br />	/*<br />	 * 分成两种:<br />	 * 不带参数的构造方法--用于创建对象<br />	 * 带参数的构造方法--创建对象的同时,初始化成员变量<br />	 * <br />	 * 构成:<br />	 * 不用写返回值,方法名就是类名,参数根据具体情况编写,<br />	 * <br />	 * 注意:构造方法不能被单独调用<br />	 */<br /><br />封装性介绍,get,set,this<br />* set方法：赋值<br /> * get方法：取值<br /> * <br /> * 因为经常要给成员变量赋值，取值。为了方法大家的使用，有一套默认的规范<br /> * set:返回值是void，方法的名字的构成set+成员变量的名字，<br /> * 但是成员变量的名字的首字母要大写，参数的类型与成员变量的一致，参数的名字与成员变量一致<br /> * 函数体内完成是赋值<br /> * <br /> * get：返回值的类型与成员变量一致，方法的名字是get+成员变量的名字，但是成员变量的名字的首字母要大写，<br /> * 无参，所以直接加一个（）即可<br /> * 函数体内将当前成员变量返回<br /><br />/*<br /><br />this 的理解:<br />		 * 理解this:是一个关键字,是一种引用类型,每个对象都有一个this,指向的是当前的对象,保存的是当前对象的地址<br />		 * <br />		 * 作用:1.成员变量与局部变量同名,区分他们<br />		 * 2.在构造方法中调用其他的重载的构造方法,提高复用,只能用于构造方法<br />		 * <br />		 * <br />		 * 注意:1.不能自己调用自己,死循环<br />		 * 2.在构造方法中,必须放在第一行<br />		 * 3.在类内部起作用<br />		 */<br /><br /><br />//1，将给定数组进行反转。{32,65,12,89,41} {41,89,12,65,32}<br />//2，将给定的数组变成字符串，[元素1,元素2...]<br />			//{34,12,65} --&gt; "[34,12,65]"<br /><br />static 介绍<br />	/*<br />	 * <br />	 * static:可以修饰成员变量,也可以修饰成员函数<br />	 * <br />	 * 被stataic修饰的成员变量的特点:<br />	 * 1.被当前类的所有对象共享<br />	 * 2.随着类的加载在方法区的静态区开辟空间,所以优先于非静态变量<br />	 * 3.可以通过类名和引用访问<br />	 * <br />	 * 对比:<br />	 * 静态成员变量和非静态成员变量的对比:<br />1:存储的数据<br />  非静态成员变量存储的是其所属类的每个对象特有属性的数据<br />  静态成员变量存储的是其所属类的所有对象共享属性的数据<br />2：存储的位置<br />  非静态成员变量是随着对象的创建在堆中开辟内存<br />  静态成员变量是随着类的加载在方法区中的静态区开辟内存<br />3: 生命周期<br />  非静态成员变量是当其所属的对象被创建时才开辟内存，当其所属的对象被垃圾回收时就释放内存<br />  静态成员变量随着类的加载在方法区中的静态区开辟内存，程序退出时才释放内存<br />4：访问方式<br />  非静态成员变量只能通过对象来访问<br />  静态成员变量既可以通过对象来访问也可以通过类名直接访问<br />  <br />  <br />  static 修饰的方法<br />  静态的只能调用静态变量,非静态的可以调用静态的和非静态的<br />	 */<br /><br />应用--封装工具类<br /><br />静态代码块<br />//静态代码块:随着类的加载就执行,只执行一次,优先于main函数<br />	//可以用于类的初始化<br /><br />构造代码块<br />//构造代码块<br />	/*<br />	 * 构造代码块儿  {}<br />	 * 1.随着对象的创建被执行    2.每次创建一个新的对象都会被执行一次    3.执行的优先级高于构造方法<br />	 * 构造函数和构造代码块儿的比较：<br />	 * 构造代码块可以对所有对象进行初始化<br />	       构造函数只能针对特定的对象进行初始化<br />	       <br />	         静态代码块儿和构造代码块儿<br />       相同点：优先级都比构造方法高，都是脱离于对象之外的<br />       不同点：静态代码块儿只执行一次，构造代码块儿，每次创建一个新的对象都会被执行一次。<br />	       */<br />练习:求圆的面积和周长<br /><br />单例设计模式:<br />/*设计模式：前人总结的一套经验（代码模板），后人拿来直接使用。作用：是让开发者解决问题的过程变得简单化<br /> * 单例设计模式：一个类只允许创建一个实例（对象），他可以提供一个全局的访问点。<br /> * <br /> * 1.将构造方法私有化，这样在类的外面就无法调用这个构造方法<br /> * 2.在类的内部创建一个当前类的实例，并将这个实例的引用静态化<br /> * 3.创建一个静态的方法，将这个实例对象提供出去，在外部就可以通过调用这个方法的方式拿到这个类的唯一对象<br /> * <br /> * */<br />饿汉式<br />懒汉式<br /><br /><br /><a name="h1-3"></a><h1>第五天</h1><br />//求两点之间的距离<br /><br />继承:<br />	/*<br />	 * 继承:当两个类之间拥有了一定的关系,父子关系,称两个类是继承关系<br />	 * 继承的一方是子类,被继承的一方是父类,父类可以有多个子类,子类只能有一个直接的父类<br />	 * 特点:简化代码,更方便操作,提高了程序的安全性,提高了程序的健壮性,增加了代码的复用性,使类与类之间产生了关系<br />	 * <br />	 * 子类可以得到父类的所有东西,除了private修饰的<br />	 * <br />	 * 关键字 extends   子类  extends 父类<br />	 * <br />	 * 继承中的成员函数:<br />	 * 方法的调用:1.对象首先会在自己的内部找到这个方法,找到了,执行,找不到,到自己的父类中找<br />	 * <br />	 * 重写:当子类与父类有同名方法的时候,这种现象叫方法的重写<br />	 * 特点:对象会优先执行自己里面的同名方法<br />	 * 注意:1.父类中的私有方法不能被重写<br />	 * 2.子类在重写父类中的方法时,子类中方法的权限要大于等于父类的<br />	 * 3.静态的只能覆盖静态的<br />	 * <br />	 * 重写的作用:子类想实现属于自己的功能<br />	 * 如果同时想实现父类的--super<br />	 * <br />	 * this是引用,代表当前的对象    super:不是引用,可以调用父类的方法<br />	 * <br />	 * 构造函数:<br />	 *继承中构造函数的特点:在创建子类对象时，总是先执行父类的构造方法，再执行子类的构造方法<br />                       原因是系统自动在子类的构造方法的第一行加入了一条语句 super()<br />					   super()默认是调用父类中无参的构造函数<br /><br />为什么要先调用父类的构造方法?子类继承父类，必然会把父类中的属性继承过来，<br />                             可以利用父类的构造方法对继承过来的属性进行初始化<br /><br />注意:如果父类中没有空参的构造方法,只有有参的，那么子类必须手动加入 super语句,调用父类的有参构造方法<br />	 */<br /><br />/*让两个类之间产生关系<br /> * <br /> * 继承：能用谁是谁表述<br /> * <br /> * 传参：将一个对象的引用通过参数传递到一个类的内部<br /> * <br /> * 组合：能用谁拥有谁表述<br /> * <br /> * <br /> * */<br />final:<br />/*final ：可以修饰 类，方法，成员变量，局部变量<br /> * 一个类被修饰为final的，那么这个类不能有子类<br />一个方法被修饰为final的，那么这个方法不能被重写<br />一个成员变量或者局部变量被修饰成final的，那么这个变量的值不能被修改，作为参数的形式参数也一样<br /> * <br /> * 只要被final修饰了，这个事物就不能再被改变<br /> * <br /> * 举例： 求圆的面积  //符号常量 //取别名<br /><br />单例//		s = new Single();//这里是错的，s被final修饰后，他保存的地址变成不可改变的，地址不能改变，所以地址对应的对象也就不能变了<br /> * */<br /><br />抽象类<br />/*<br />//抽象类：在提取父类的时候，每个子类都有自己的实现方式，父类不能决定如何实现，<br />//那就不决定了，我们在父类中只写方法的声明，不写实现，我们成这样的方法是抽象方法，有抽象方法的类是抽象类<br /><br />/*特点：1.抽象类不能创建对象<br />* 2.继承了抽象类的类，如果没有实现抽象类的方法，那这个子类也是抽象类<br /><br />* 1.抽象类是父类吗？<br /> * 是<br /> * 2.抽象类与普通类区别：<br /> * 不同点：<br /> * a：抽象类不能创建对象，普通类可以<br /> * b：抽象类可以含有抽象方法，普通类不可以<br /> * 相同点：<br /> * 都是类，都是在描述事物<br /> * <br /> * 3.abstract不可以跟那些关键字并用<br /> * final：使用final修饰的方法不能被重写，abstract必须可以重写<br /> * static：可以通过类名调用，abstract不能被调用<br /> * private：使用private修饰的方法不能被重写，abstract必须可以重写<br /> * <br /> * 4.一定有抽象方法吗？<br /> * 不一定，只要是不想让当前类创建对象<br /> * <br /> * 抽象类也是类，用来描述事物，只是包含有一些没有实现的方法<br /><br />例子://举例： 计算圆和矩形的面积   final   abstract<br /><br />作业:/*需求：公司中程序员有姓名，工号，薪水，工作内容。<br />项目经理除了有姓名，工号，薪水，还有奖金，工作内容。<br />对给出需求进行数据建模。*/    super  abstract<br />*/<br /><br />接口<br />/*接口：<br /> * interface 接口名字{<br /> * 		public static final 成员变量；////接口是抽象的，不能创建对象（实例化），<br />	                        //不要在里面放入非静态的成员变量<br />	                        //，static是静态的，可以通过接口名称调用，<br />	                         //final：因为这里要得到一个不能改变的存储空间<br /> * 		public abstract 成员方法；<br /> * }<br /> * <br /> *  * 接口解决了java的单继承的问题<br /> * 因为接口中的方法都是抽象的，一个类在实现接口时，重写了接口中的抽象方法<br /> * 当创建子类对象并调用该方法时，很明确是在调用重写之后的方法，所以不会出现调用的不确定性<br /> * <br /> * //注意：当一个类实现了一个接口，接口中的东西，类都可以使用<br /> * 一个<br /><br />/*一个类在继承的同时可以实现接口<br /> * <br /> * 类与类之间的产生的关系叫继承<br /> * 类与接口之间产生的关系叫实现<br /> * <br /> * 通过继承实现的是基本功能<br /> * 通过接口实现的是额外的功能，或者叫对基本功能的补充<br /> * <br /> * <br /> * 注意：接口与接口之间也存在继承关系，可以多继承<br /> * */<br /><br />/*1：接口是一些规则<br />2：可以提高程序的扩展性<br />3：降低类之间的耦合关系<br /><br /><br />//举例：说明抽象类 犬科动物--- 警犬，导盲犬，搜爆犬    接口  扩充功能  <br /> * */<br />多态:<br /><br />/*多态：是一种事物的多种形态        猫== 动物== 生物<br /> * 前提：类之间要有继承关系<br /> * 多态：父类的引用指向子类的对象，就叫多态<br /> * 缺点：只能访问父类中定义的功能<br />       好处：可以提高程序的扩展性，前期定义好的功能后期可以使用<br /> * <br /> * //父类的引用指向子类的对象，就叫多态<br /> */<br /><br />//只能访问父类中定义的功能,因为程序分成预编译，编译和运行三个阶段，<br />		//真正的让后面的对象去调用方法，是在运行阶段，而在编译阶段,当前的引用所能够调用的方法取决于当前引用的类型<br /><br />Person person = new Person();<br />//这里进行强转,相当于将父类的对象强制转化成子类的对象<br />//Student student2 = (Student)person;<br /><br /><br />举例://猫，狗，猪---- 动物<br /><br /><br />//在多态中访问子类中特有的功能<br />//动态加载，动态绑定，动态类型<br />//动态加载：在编译的时候不识别真正的对象，在运行的阶段才由真正的对象去调用方法。<br />		//这是多态，只能调用父类拥有的方法<br />向上转型   Animal pig = new Pig("齐齐",23);//向上转型<br />	pig.show();--show是父类中有的方法<br />向下转型----//在多态中访问子类中特有的功能<br />	//强制类型转换<br />		Pig p1 = (Pig)pig;//向下转型<br />		p1.run();<br /><br />//实例  instanceof 类       ：这是一个运算符，专门用来判断前面的实例（对象）是否是后面的类的对象，<br />		//或者是后面的类的子类的对象,如果成立，返回ture  ，否则返回false<br />        //这是在运行时起作用的运算符<br /><br />//多态当中<br />//成员变量:编译的时候能访问哪个成员变量看父类,运行的时候还看父类<br />//非静态的成员方法:编译的时候能访问那些成员方法看父类,运行时看子类(如果没有进行重写,还是看父类)<br />//静态的成员方法:编译,运行都看父类。<br /><br />///接口和多态--实现了接口的类可以看成接口的子类<br /><br />理解作业:<br />/*<br />根据以下这段话的描述，用面向对象的思想实现<br /><br />狗生活在陆地上（是一种陆生动物），既是哺乳(mamma)类的。<br />狗通常的时候和人打招呼会通过“摇摇尾巴”，<br />在被抚摸情绪很好的时候，会“旺旺叫”，<br />而在受到惊吓情绪(mood)烦躁时，会发出“呜呜”声；<br /><br />猫也生活在陆地上（是一种陆生动物），既是哺乳类。<br />猫通常的时候和人打招呼会发出“喵～”的声音，<br />在被抚摸情绪很好时，会发出“咕噜咕噜”声，<br />而在受到惊吓情绪烦躁时，会发出“嘶嘶”声；<br /><br />青蛙是一种两栖动物（既是水生动物也是陆生动物），既不是哺乳类的，属于卵生。<br />青蛙通常的时候和人打招呼会通过"呱呱叫"，<br />当青蛙情绪好的时候，会在岸边“呱呱呱”的唱歌，<br />而在受到惊吓情绪烦躁时，会"扑通一声跳入水中"<br />*/<br /><br />Object<br /><br />//	    hashCode  对象的哈希码值<br />	    System.out.println( p1.hashCode());//31168322  哈希值的十进制值<br />	   //toString   默认调用toString方法<br />	    System.out.println(p1);//day10Project.Person@1db9742<br />	    System.out.println(p1.toString());//day10Project.Person@1db9742<br />	    //Integer是一个整形类，专门用来操作整型数据的<br />	    System.out.println(Integer.toHexString( p1.hashCode()));//1db9742  哈希值的十六进制值<br />	    //Class:这是类类型  <br />	    Class cla =  p1.getClass();<br />	    System.out.println(cla);//class day10Project.Person  --- 这个类的字节码文件，将这个对象的字节码文件面向对象处理了<br />	    String claName =  cla.getName();<br />	    System.out.println(claName);//day10Project.Person<br />	    //这就是toString方法中默认打出的值<br />	    System.out.println(p1.getClass().getName() + "@"+Integer.toHexString(p1.hashCode()));<br /><br /><br />/*内部类：在一个类内部定义的类,内部类属于外部类的成员，所以和外部类中的其他成员是平级的，所以可以相互使用<br />//内部类可以直接使用外部类中的成员<br /> * <br /> * <br /> * */<br /><br /><br />//静态成员内部类:如果内部类中含有静态成员，那么内部类必须是静态的<br />////内部类中获取外部类对象：外部类名.this,如果直接调用外部类的静态的成员变量，直接使用外部类名<br /><br /><br />//局部内部类:只能在它所在的函数使用,<br />	//jdk1.7之前局部内部类使用了其所在函数的局部变量时，该局部变量必须是final 的<br />	//jdk1.8之后不需要了,默认就是final 的<br /><br /><br />/*<br /> * 匿名内部类<br /> *前提：必须有父类或者接口<br /> *格式：  new  父类的类名(){<br /> *		当前匿名类的成员<br /> *}<br /> *<br /> *作用：简化代码<br />//匿名内部类:处于类的内部,并且是匿名的,叫匿名内部类.相当于Test的一个子类对象,匿名内部内是局部内部类的一种<br />		//匿名内部类不能使public,static,protected,private<br />匿名内部类作用:1.只用到一个实例,定义好马上使用,命名并不会更好,可以方便的定义运行时回调<br />内部类作用:1.内部类对象可以访问创建他的对象的实现,包括私有数据<br />2.内部类不为同一包的其他类所见,具有很好的封装性<br />3.可以方便定义<br /> */<br /><br />/*<br /> * 异常：在程序运行过程中出现的不正常情况<br /> * <br /> * 异常的由来：程序在运行的时候出现的不正常情况被看成了对象，<br /> * 提取了他的属性和行为（异常的位置，异常的名字，异常的信息），<br /> * 得到了各种的异常类<br /> * <br /> * throwable:总异常<br /> * Error：运行时出现的严重问题，不用写相关的代码处理<br /> * Exception：不严重的问题，通常需要进行处理<br /> * <br /><br />	/*出现异常，异常的处理过程<br />		 * 在除数为零的时候，系统会把这个除数为零的不正常情况生成一个异常类对象，<br />		 * 正常情况下，main函数不能处理，就将异常交给JVM，由JVM来处理，<br />		 * JVM默认的处理方式就是调用该异常类对象的printStackTrace()方法，打印出当前的异常 信息<br />		 * <br />		 * 当代码出现异常的时候，会打印出异常的信息，名字，地址，然后程序中断<br />		 * */<br /> */<br /><br />两种常见异常的展示   引用为null,数组越界<br /><br />/*<br /> * 执行顺序：首先在真正出现异常的方法中的代码处抛出异常，<br /> * 当前的函数没有处理异常的能力，就将异常交给调用这个函数的地方，一直向上传递，<br /> * 直到交个main，正常情况下main也没有处理异常的能力，就将异常抛给JVM，<br /> * JVM调用异常对象的打印方法，打印异常的内容，程序中断<br /> * <br /> */<br /><br />/*<br /> * 作用:检测异常,抓住异常,让当前的异常不影响程序的正常执行<br /> * try{<br /> * 		可能出现异常的代码<br /> * }catch(Exception e){抓取异常的功能<br /> * 		给异常进行处理<br /> * }<br /> * <br /> * 继续执行下面的代码<br /> */<br /><br />/*使用throws声明可能发生的异常，那么调用者必须处理<br /> *处理方式有两种   //强制处理异常，如果不进行异常的处理，编译不通过<br />1：使用try{}catch(异常类 e){}处理<br />2：继续使用throws声明可能发生异常 //只是针对main函数中的对异常的处理<br /> * <br /> */<br /><br />/*<br /> * 多重异常<br /> * <br /> * try{}<br /> * catch(){}<br /> * ...<br /> * catch(){}<br /> * <br /> * 继续执行<br /> * <br /> * 可以同时处理多个异常<br /> * 注意点：当Exception与其他的子类异常同时处理的时候，<br /> * 由于try catch在执行的时候是从上到下，要讲Exception写在最下面<br /> */<br /><br />/*<br /> * 自定义异常<br /> * 除数不能为负数<br /> */<br /><br />/* * 使用throw手动抛出异常，不用处理，编译通过<br />* 使用throws手动声明异常，不用处理，编译通过<br />* <br />* 异常分类：<br />* 一种是编译时检测的异常，必须处理，不处理不通过<br />* 一种是编译时不检测的异常，可通过   (运行时异常)<br />*/<br /><br />/*<br /> * try{检测异常<br /> * 		可能发生异常的代码<br /> * }<br /> * catch(Exception e){//抓住异常<br /> * 	    对异常的处理<br /> * }<br /> * finally{<br /> * 	//必须执行的代码     作用：当多线程，数据库中的内存被回收的时候的代码可以放在这里<br /> * }<br /> * <br /> * <br /> * <br /> * try{<br /> * 		获取资源<br /> * }finally{<br /> * 		释放资源<br /> * }<br /> * */<br /><br />异常例子:<br />//老师用电脑上课<br />//老师上课时异常<br /><br />//模板设计模式:在实现一个功能时，功能的一部分是确定的，另一部分是不确定的，<br />//确定的部分还会用到不确定的部分，那么就把不确定的部分暴露出去，让子类去完成<br /><br />/*<br /><br />计算一个程序的运行时间：<br />获取程序运行的开始和结束时间是确定的，然后两个时间相减<br />被计算运行时间的程序是不确定的<br />*/<br />//上课时电脑的异常：蓝屏，冒烟<br /><br />第八天<br />//字符串   String字符串类<br />//这是一个常量,被放在常量池中,常量池可以理解成在特殊的堆里,这个字符串对象是不能再被改变的(final修饰)<br />//执行s1,先到常量池中找,看有没有当前的字符串,有s1指向他的地址,没有,生成一个字符串<br />    	//<br />//传入的作为参数的字符串是常量池中的字符串(共享),但是new出来的对象是堆中的新的对象<br />//比较的是传入的作为参数的字符串<br />//重写了toString()方法<br /><br /><br />一些常用的方法<br />//验证用户名和密码是否正确<br />throw new NullPointerException();<br />//验证邮箱是否合法<br />throw new NullPointerException();<br /><br />*/<br />/*<br />   判断：<br />        判断是否包含一个字符串<br />		  boolean contains(CharSequence s) <br />        判断两个字符串的内容是否相同<br />		  boolean equals(Object anObject) <br />        忽略大小写判断两个字符串的内容是否相同<br />		  boolean equalsIgnoreCase(String anotherString) <br />         判断是否以某字符串开头<br />		   boolean startsWith(String prefix)<br />		 判断是否以某字符串结尾<br />		   boolean endsWith(String suffix) <br />    转换：将字符数组转换成字符串<br />			  1:使用构造方法<br />				 String(char[] value) <br />				 String(char[] value, int offset, int count) <br />			  2:使用静态方法<br />				 static String copyValueOf(char[] data) <br />				 static String copyValueOf(char[] data, int offset, int count) <br />		  将字符串转成字符数组<br />              char[] toCharArray() <br /> <br />		  将字节数组转成字符串<br />		      String(byte[] bytes) <br />              String(byte[] bytes, int offset, int length)<br />			  String(byte[] bytes, String charsetName)//使用指定的编码将字节数组转换成字符成<br />		  将字符串转成字节数组<br />		      byte[] getBytes() <br /> <br /><br />		  将基本数据类型转换成字符串<br />		      String.valueOf()<br />    替换：<br />	     String replace(char oldChar, char newChar) <br /> <br />	子串:<br />	     String substring(int beginIndex)  <br />		 String substring(int beginIndex, int endIndex) //包含起始位置，不包含结束位置，到结束位置的前一位<br /> <br />	转换，去除空格，比较:<br />	     大小写转换<br />		     String toLowerCase() <br />             String toUpperCase()<br />		 将字符串两端的空格去掉<br />		     String trim() <br />		 按字典顺序比较两个字符串<br />             int compareTo(String anotherString)<br />	切割: String[] split(String)<br /><br />*/<br /><br />/*<br />存储：<br />    StringBuffer append(boolean b) <br />    StringBuffer insert(int offset, boolean b)<br />删除：<br />     StringBuffer delete(int start, int end) <br />     StringBuffer deleteCharAt(int index)<br />修改：<br />     StringBuffer replace(int start, int end, String str) <br />     void setCharAt(int index, char ch)<br /><br />获取：<br />     char charAt(int index) <br />	 int indexOf(String str)<br />	 int indexOf(String str, int fromIndex)<br />	 int lastIndexOf(String str) <br />          返回指定子字符串在此字符串中的索引从右到左查。 <br />     int lastIndexOf(String str, int fromIndex) <br />          返回指定子字符串在此字符串中的索引,从右到左查,范围:0-当前指定的位置。 <br />     int length() <br />          返回长度（字符数）。 <br /><br />反转：<br />     StringBuffer reverse() <br /><br />从jdk1.5出现了StringBuilder,它是线程不安全的<br />在不需要多线程安全的前提下建议使用StringBuilder,执行的效率高<br /><br />jdk升级的原因：<br />1：提高效率<br />2: 提高安全性<br />3: 简化书写<br /><br /><br />/*<br />包装类 ：<br />byte    Byte<br />short   Short<br />int     Integer<br />long    Long<br />char    Character<br />boolean Boolean<br />float   Float<br />double  Double<br /><br />可以实现基本数据类和字符串类型之间的转换<br /><br />基本类型转成字符串类型<br />    static String Integer.toString(int i)<br />    static String Double.toString(double d)<br />字符串类型转基本类型<br />    int     Integer.parseInt("23")<br />	double  Double.parseDouble("3.45")<br /><br />把十进制转成其它进制<br />   Integer.toHexString()<br />   Integer.toOctalString()<br />   Integer.toBinaryString()<br /><br />把其它进制转十进制<br />  Integer.parseInt(数据,进制)<br />*/<br /><br />//装箱:就是将简单的数据类型用对应的类进行封装<br />//拆箱：将这个简单的数据类型从对象中取出来<br /><br />jdk1.5之后自动装箱,拆箱<br /><br /> //一个数在一个字节允许的范围之内，如果之间已经定义过，那么再定义时使用已有的<br />Integer i1 = 127;<br />		Integer i2 = 127;<br />		sop(i1== i2);<br />		//如果出了一个字节的范围，那就是两个数<br />		Integer i11 = 128;<br />		Integer i22 = 128;<br />*/<br /><br />//Date类<br />输出时间<br />long转Date<br />Date转long<br /><br />//DateFormat  ---日期的格式化<br />DateFormat 创建系统的类   getDateTimeInstance(DateFormat.FULL,DateFormat.LONG)<br />SimpleDateFormat  创建自定义的类   new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");<br /><br />//Calendar  <br /><br />//Maths<br />//最小值  最大值    平方   开方   随机数  随机类<br /><br /><br />/*集合：<br /> * <br /> * 可以存储不同类型的数据<br /> * Object[]<br /> * 确定：创建的是一个定值，只能存储固定数量的数，一旦存满了，就不行了<br /> * <br /> * 集合：<br /> * 可以存储不同类型的对象，而且随着存储的对象的增加容量自动扩大<br /> * 注意：集合里面只能存对象<br /> * 类型：List（vector，ArrayList，LinkedList），set（HashSet，TreeSet）<br /> * <br /> * /*<br />Collection中定义是整个集合体系最共性的方法:<br />添加：<br />   boolean add(Object o) <br />   boolean addAll(Collection&lt;? extends E&gt; c)  <br />删除:<br />   boolean remove(Object o)  <br />   boolean removeAll(Collection&lt;?&gt; c)<br />   void clear()<br />判断:<br />   boolean contains(Object o) <br />   boolean containsAll(Collection&lt;?&gt; c)<br />   boolean isEmpty() //判断集合是否为空<br />   boolean equals(Object o) <br />获取：<br />   Iterator&lt;E&gt; iterator() //获取集合中的对象<br />   int size() //获取集合中对象的个数<br />集合变数组：<br />   Object[] toArray()<br />*/<br /><br /><br />迭代器的使用<br />/*Collection<br /> * <br /> * 一 List:存储的对象是有顺序的（集合中对象的顺序和添加对象的顺序保持一致），可以重复的    <br /> * ArrayList：底层的数据结构是数组，是线程不安全的，查找对象的速度快，添加删除速度慢<br /> * LinkedList：底层的数据结构是链表，是线程不安全的，查找对象的速度慢，添加删除的速度快<br /> * Vector：底层使用的数据结构是数组，线程安全的，查找速度快，增删速度慢，被ArrayList替换<br /> *           <br /> * <br /> * 二Set：存储的对象是无序的，不可以重复<br /> * HashSet<br /> * TreeSet<br /> * <br /> * List：特有方法，可以操作下标<br />增：<br />    void add(int index, E element) <br />    boolean addAll(int index, Collection&lt;? extends E&gt; c) <br /><br />删<br />   E remove(int index) <br /><br />改<br />   E set(int index, E element)<br /><br />查<br />     ListIterator&lt;E&gt; listIterator() <br />     返回此列表元素的列表迭代器（按适当顺序）。 <br />     ListIterator&lt;E&gt; listIterator(int index) <br />     List&lt;E&gt; subList(int fromIndex, int toIndex) <br />     E get(int index) <br />     <br />     删除全部对象<br />*/<br /><br /><br />	//增加<br />				List list = new ArrayList();<br />				list.add("java1");//默认是在集合的末尾添加元素<br />				list.add(0, "java2");//通过下标添加元素<br />				list.add(2, "java3");<br />				sop(list);<br />//				Iterator ite = list.iterator();<br />//				while(ite.hasNext()){<br />//					Object obj =  ite.next();<br />//					if("java3".equals(obj)){<br />////						list.remove("java3");//在低版本的jdk中调用积极和的remove方法会报ConcurrentModificationException，在高版本的jdk中做了处理<br />////						ite.remove();<br />//					}<br />//				}<br />//				sop(list);<br />				<br />				ListIterator listIte = list.listIterator();<br />				while(listIte.hasNext()){<br />					Object obj = listIte.next();<br />					if("java3".equals(obj))<br />//					   listIte.add("javazeng");<br />//						listIte.remove();<br />						listIte.set("java6");//注意：set方法不能与add和remove方法同时使用，否则会报IllegalStateException<br />				}<br />				sop(list);<br /><br /><br /><br />/*<br />LindedList<br />特有的方法：<br /><br />addFirst()//始终在首位添加<br />addLast()//始终在末尾添加<br /><br />getFirst()//获取的对象不存在会发生异常<br />getLast()<br /><br />removeFirst()//删除的对象不存在会发生异常<br />removeLast()<br /><br />从jdk1.6开始出现以下方法<br />offerFirst()<br />offerLast()<br /><br />peekFirst()//获取的对象不存在会返回null<br />peekLast()<br /><br />pollFirst()//删除的对象不存在会返回null<br />pollLast()<br />*/<br /><br />//使用LinkedList模拟队列<br /><br />/*<br />去重<br />contains 依据的是equals（Object o）方法 <br />*/<br /><br />/*<br />给自定义的类去重，理解去重<br />*/<br /><br /><br />/*set:存储的数据没有顺序，数据不能重复<br /> * <br /> * HashSet：底层使用的是哈希表,实现的是HashMap(key-value)的实例，线程不安全的<br /> * 保证对象唯一的方式: int hashCode()   boolean equals(Object obj)<br />            在添加对象时先用对象的哈希值和集合中对象的哈希值分别进行比较，如果和<br />		   集合中所有对象的哈希值都不相同，那么直接把对象加入集合，如果出现哈希值相同的<br />		   那么再调用 equals方法对象哈希值相同的两个对象进行比较，如果equals方法返回true<br />		   则认为是同一对象，不把该对象加入集合，否则认为是不同的对象，加入集合<br /> * <br /> * <br /> * */<br /><br />/*TreeSet：底层使用的是二叉树，线程不安全的<br />可以对存入集合的对象进行排序<br />基于 TreeMap 的 NavigableSet 实现<br />排序方式一:集合中对象所属的类 实现了Comparable接口中的int compareTo()方法<br />           TreeSet依据该方法进行排序<br /><br />			 保证对象唯一的方式： compareTo()方法的返回值是0<br />*/<br /><br /><br />//使用LinkedList模拟栈<br /><br />第二种方法: Comparator   -  compare(Object obj1,Object obj2)<br />对象唯一方法:方法返回值为0<br />class CompareWithLength implements Comparator<br /><br />	public int compare(Object obj1,Object obj2 ) {<br />		//先判断传入对象的类型，确定是字符串类型<br />				if(!(obj1 instanceof String))<br />					throw new ClassCastException();<br />				if(!(obj2 instanceof String))<br />					throw new ClassCastException();<br />				<br />				//强制类型转化<br />				String str1 = (String)obj1;<br />				String str2 = (String)obj2;<br />				System.out.println(str1+"  "+str2);<br />		   int num = str1.length()-str2.length();<br />         if (str1.equals(str2)) {<br />			return 0;<br />		}<br />	if (num &gt; 0) {<br />		return 1;<br />	}<br />	<br />	return -1;<br />		<br />	};<br /><br />//给自定义的对象进行排序<br />/*<br /> * 1.实现了Comparable接口中的int compareTo()方法<br /> * 2.自定义排序类，实现Comparator接口中的int compare方法<br /> * <br /> * */<br /><br />//"23 45 12 6 78"   将这个字符串里面的数字进行排序<br /><br />/*<br />泛型：通过&lt;数据类型&gt;接收一种引用数据类型，在编译程序时会使用该类型检查集合中存储的对象是否是该<br />      类型的，如果不是，编译不通过，从而把运行时期的问题转移到编译时期，提高了程序的安全性<br />      <br />    使用了泛型之后，就不需要再进行强制转化<br />    <br />    泛型擦除：泛型是用在编译时期的，编译完之后的class文件中是不存在泛型的<br />*/<br /><br />修饰类<br /><br />修饰方法<br /><br />修饰接口<br /><br />通配符?<br /><br />&lt;? extends E&gt; 限制上限<br />&lt;? super E&gt; 限制下限<br /><br />/*Map:是通过键值对的形式存储数据，他不是Collection类型的，但是他是集合，存值的时候是一对一对的，是一个单独的接口。<br /> * HashMap：底层的数据结构是哈希表，线程不安全的<br /> * TreeMap：底层的数据结构是二叉树，线程不安全的<br /> * <br /> * 添加:<br /> V put(K key, V value) <br /> void putAll(Map&lt;? extends K,? extends V&gt; m)<br /> <br />删除:<br /> V remove(Object key) <br /> void clear() <br />         <br />获取：<br />  V get(Object key) <br /><br />  Set&lt;K&gt; keySet() <br />  Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() <br />  int size() <br />  Collection&lt;V&gt; values() <br />判断:<br />   boolean isEmpty() <br />   boolean containsKey(Object key) <br />   boolean containsValue(Object value) <br /><br />*/<br /><br />/*遍历 Set&lt;K&gt; keySet(): 得到所有键的集合存储到一个Set中，并返回该Set集合，因为Set有迭代器<br />所以使用迭代器迭代，每次迭代出一个键，再根据键获取值<br /><br />Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 得到每个键值对对应的映射关系类型的值，存到Set集合中，并<br />  返回该集合，因为Set有迭代器，每次迭代出来的是一个映射关系类型的值，从这个<br />	映射关系类型的值中既可以得到键，也可以得到值<br />	Entry是定义在Map中的一个静态接口，<br />	有了集合，有了集合中的键值对，才会存在映射关系，所以映射关系是对集合内部<br />	事物的描述，所以定义在Map内部<br />*/<br /><br />//举例：每个学生对应一个地址<br />//key：必须是唯一的，value：可以重复<br />//Collection:直接存储的是值<br />//Map:存储的是键值对，通过key取value<br /><br />/*HashMap:可以通过hashCode和equals方法实现去重<br /> *TreeMap:可以通过实现接口Comparator的compare方法或者Comparable的compareTo方法实现去重和排序<br /> *注意：当compare和compareTo方法同时实现的时候，优先执行自定义的方式，即compare方法<br /> * <br /> * <br /> */<br /><br />//通过自定义比较类排序<br /><br />Runtime<br />//每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。<br /><br />//练习:字符串"oeiproitwoeuraecdefgabcdefg"<br />//希望打印结果:a(2)b(1)c(2)<br /><br />//有两个班级，每个班级有多个学生，遍历所有班级并显示每个班所有学员<br /><br />//Arrays:此类包含用来操作数组（比如排序和搜索）的各种方法。<br /><br />/*<br /> * Collectons:<br /> * 专门用来操作结合的工具<br /><br />//默认的排序方法：这个方法要求泛型T必须实现comparable接口中的compareTo方法<br />		//此处由于String内部已经实现了compareTo方法，所以可以直接实现排序<br />//从短到长排序<br />//从长到短<br /><br />//返回一个比较器,他会按照字典排序的逆序输出<br />//按照逆序输出<br />//求最大值(默认按字典排序的最大值)--可以指定排序规则<br /><br />//Collection 里面的toArray方法<br /> 		<br /> 		//可以转化成指定类型的<br /> 		//注意:转化时,指定的数组大于集合,以数组.小于集合,以集合<br /> 		//所以最后相等<br /> */<br /><br />* 格式  <br />* for(数据类型 变量:要遍历的数组或集合)  此处的集合不包括Map<br />* {<br />* }<br />* <br />* 单独遍历Map<br />* <br />* <br />* 可变参数:简化书写<br />* <br />* 静态导入<br />* <br />*/<br /><br />/* 多线程<br />* 程序：可以执行的一个文件<br />* 进程：正在运行的一个程序，也就是在内存中开辟的一块儿内存空间<br />* <br />* 线程：负责程序执行的一条执行路径（代码片段），也可以称为一个执行单元<br />*     进程的执行实际上是线程在执行<br />*     一个进程至少要有一个线程<br />*     当一个进程中有多个线程的时候，我们称之为多线程<br />*     <br />* 优点：可以让多个功能同时执行<br />* 缺点：不会增加执行的效率，但是可以更加合理的使用cpu<br />* <br />* JVM是多线程吗？是<br />* 至少有两个线程工作：<br />* 一个是负责代码执行的线程，我们称之为主线程，工作的位置是main函数<br />* 一个负责垃圾回收的线程，称为垃圾回收线程，工作的位置是finalize函数<br />* <br />* 任务：每个线程需要执行的代码，都有自己的内存空间<br />* 主线程的内存空间：main函数<br />* 垃圾回收线程：finalize函数<br />* <br />* <br />* <br />* <br />*/<br />class Test{<br />	@Override<br />	//当对象不再被使用的时候，会由系统调用finalize方法，进行垃圾回收<br />	//这里是为了演示，所以重写了finalize方法<br />	protected void finalize() throws Throwable {<br />		// TODO Auto-generated method stub<br />		System.out.println("垃圾回收");<br />	}<br />}<br />public class Demo9 {<br />	public static void main(String[] args) {<br />		new Test();<br />		new Test();<br />		//运行垃圾回收器，触发垃圾回收机制<br />		//当执行完下面的代码，垃圾回收机制被触发，垃圾回收线程被打开，所以现在有两个线程<br />		//线程是有随机性的，因为多个线程在执行功能的时候，是抢CPU。<br />		System.gc();<br />		<br />		System.out.println("结束");<br />		<br />		//线程是随着任务的存在而存在，任务的结束而消失<br />		//有线程在工作，进程不会自动关闭。<br />	}<br />}<br /><br /> * 创建多线程<br /> * <br /> * 让两个show方法同时执行？<br /> * 解决办法：单独创建一个线程<br /> * 1.创建Thread线程类的子类<br /> * 2.重写Thread的run方法<br /> *        执行任务<br /> *        任务代码必须有存储位置，run方法就是线程的存储位置<br /> * 3.创建子类的对象<br /> * 4.启动线程<br /> *      主线程的任务代码在main中<br /> * 		子线程的任务代码在run方法中 <br /> * <br /> * 问题：run是子线程的任务执行位置，为什么不直接调用他？<br /> * run方法不能被单独调用，如果单独调用，他只是一个简单的方法，不具备启动线程的功能<br /> * 只有通过调用start方法，通过系统间接的调用run方法，才能启动线程。<br /> * <br /> * 为什么不直接使用Thread创建线程,而使用它的子类？<br /> * 1.程序规定Thread类的run方法不执行任务<br /> * 2.我们要做的是自己的事，系统无法帮我们完成，只能重写run方法<br /> */<br />//任务与线程绑定在了一起，不方便<br /><br />问题分析:1.有获取cpu的资格,但是没有得到cpu,是阻塞状态还是就绪状态???<br />2.cpu的个数有1个,2个,4个,有没有3个?6个?<br />3.在eclipse中\b打出的是乱码???<br /><br /> * 4个人同时卖票<br /> * 解决办法：多线程<br /> * 同时创建4个线程，分别去卖票<br /> * <br /> * 创建线程的第二种方法：利用Runnable接口<br /> * 1.创建实现了Runnable接口的子类<br /> * 2.在子类中重写run方法<br /> * 3.创建子类的实例对象------任务<br /> * 4.通过thread创建一个线程<br /> * 5.通过传参的方式，将任务交给线程<br /> * <br /> * 比较两种创建线程的方式：<br /> * 第二种<br /> * 实现了线程任务与线程对象的分离，线程执行什么任务不再是唯一的，<br /> * 只要是实现了Runnable子类的对象都可以作为任务，作为参数传递给线程对象的构造方法即可<br /> *<br /> * 第一种：<br /> * 任务与线程绑定在了一起，不方便<br /> * <br /> * 第二种在实现接口的同时还可以继承父类，所以不影响子类的正常工作，而第一种直接将子类与线程进行了绑定，运行起来不方便<br /> */<br /><br />/*<br />安全问题:<br />多线程执行一个任务,出现的错误,可能会出现0,-1,-2,-3等错误的值<br /><br />出现原因分析:<br />1.多个线程操作了相同的数据<br />2.共享数据的语句有多条,一个线程得到cpu,执行了多条语句中一部分时,还没有全部执行完,<br />就被抢走了cpu,当线程再次得到cpu时,直接执行后面的语句导致问题的出现<br /><br />解决办法:Java中使用同步代码块儿(同步锁)<br />同步:在某一段任务中,只允许一个线程占用cpu,其他的线程处于等待状态,当这个线程完成这段任务后,让出cpu,其他的线程才能抢走cpu<br /><br />synchronize(对象){<br />	//某段任务<br />}<br /><br />注意:对象就充当的是钥匙的角色,1.钥匙必须是对象  2.保证钥匙对于多个线程只有共享的一份<br /><br />同步代码块儿的缺点:线程每次都要判断锁,降低了程序的性能<br /><br />使用同步的条件:<br />1.至少有两个线程<br />2.多个线程使用同一把锁<br /> */<br /><br />/*<br /> * 一个银行可以存钱<br />两个储户同时向一个账户存钱，每人存3次，每次存100<br /><br />分析:同时存  使用多线程<br />两个储户:新建两个线程<br />任务:向银行存钱<br /><br />常见银行类,任务类<br /><br />//注意：当synchronized修饰函数的时候，对于非静态的函数，同步锁（钥匙）是对象本身，即this<br />	//对于静态的函数，同步锁是当前类的字节码文件（对象）<br />	//原因：静态同步函数在进内存的时候不会创建对象，但是存在其所属类的字节码文件对象，属于class类型的对象，所以<br />	 // 静态同步函数的锁是其所属类的字节码文件对象<br />	<br />	//当在一个类中同时存在多个synchronized修饰的代码块儿或函数时，要想安全，就必须让他们后面的对象一致。<br />	//因为只有让他们同时使用同一把钥匙才能安全。<br />	 * <br />	 *  2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，<br />	 表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象；<br /><br />	 3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} <br />	 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定<br />	 它的某个方法为synchronized方法；<br />*/<br /><br />/*<br /> * //死锁：同时存在多个锁，并且相互嵌套调用，这时有可能发生，同时互相占用，无法工作的情况。<br />//注意：在以后的开发当中，应该尽量避免死锁的出现<br /> */<br /><br />/*<br /> * 单例的安全问题<br /> * <br /> */<br /><br />/*<br /> * 两个线程之间的通信:每个线程都有自己的任务,使用同一份数据<br /> * <br /> * 分析:线程数量:2个<br /> * 任务数量:2个<br /> * 数据的数量:1份<br /> */<br /><br />//对于两个不同的任务对应着各自的线程，单独使用同步没有意义。<br />				//要想给他们使用同步，就要符合同步基本条件：只要要有两个线程，<br />				//所以给这个处于不同任务的同步代码块使用同一把钥匙,这样就相当于<br />				//将两个同步代码块进行了同步，因为同步代码块在各自的线程中，<br />				//所以就把两个线程进行了同步<br /><br />/*<br /> * 两个线程间的通信：每个线程都有自己的任务，使用同一份数据<br /> * <br /> * 分析：线程数量：2个<br /> * 任务数量：2个<br /> * 数据的数量：1份<br /> * <br /> * 要实现一次输入一次输出的单输入单输出操作，所以要对线程进行等待和唤醒<br /> * wait（）让当前的线程处于等待状态，会将当前的线程放到线程池，等待唤醒<br /> * notify() 将当前的线程从等待状态唤醒，从线程池中取回线程，<br /> *          注意：在取回线程时，是取回任意一个线程，取回的线程是取回与等待操作时，要使用同一把锁<br /> * notifyAll()  唤醒被同一把锁标记的所有线程<br /> * <br /> * 注意：wait，notify等方法必须使用在同步的函数或代码块儿中，放在Object类里面，因为，只要是同步，就会有一把锁，<br /> * 所有的锁都是对象，Object类是所有对象的基类，这是，同步代码块儿里面要使用等待，唤醒等方法，每个同步进制都要有一把锁<br /> * 所以讲等待，唤醒等方法放在锁对象里，方便使用   Object obj ；    obj.wait()   <br /> */<br /><br />/*<br /> * 简化后的输入输出代码：用更加面向对象的做法实现，输入，输出是数据类的事情，所以把这两个工作交给数据类做<br /> */<br /><br />/*<br /> * 生产者消费者-----类似于输入输出机制<br /> * <br />  生产者有生产任务<br /> * 消费者有消费任务<br /> * <br /> * 生产和消费可以同时进行<br /> * 使用多线程<br /> * <br /> * 需要描述生产任务<br /> * 需要描述消费任务<br /> * <br /> * 生产的是产品<br /> * 消费的也是产品<br /> * <br /> * 需要描述产品<br /> */<br /><br />//两个生产者两个消费者，怎么工作？<br /><br />//单生产单消费是没有这个安全问题的<br /><br />//创建产品<br />/* 两个生产线程，两个消费线程，出现了生产三次，消费一次，生产一次，消费三次的问题<br />* 原因：线程被唤醒之后没有回去判断标记，直接执行后面的代码<br />* 解决：将if改为while<br />* <br />* 修改完后，线程出现了死锁<br />* 原因：唤醒的是本方的线程，导致所有线程全部等待   notify唤醒的是任意一个线程，不能保证唤醒对方的线程<br />* 解决：使用notifyAll（），将线程全部唤醒，保证对方程序被唤醒<br />*/<br /><br />/*jdk1.5之前使用的同步方法，称为隐式同步<br /> * 原来的使用同步的方法<br /> * synchronized(对象){将对象可以称为锁      获取锁   将锁称为监视器/锁旗舰<br /> * 	  同步的代码<br /> * }  释放锁<br /> * <br /> * jdk1.5之后，将锁面向对象了，使用Lock接口实现同步<br /> * 工作原理：<br /> * 1.先创建一个锁的对象，使用锁接口的子类创建。<br /> * 2.调用lock（）方法，获取锁<br /> *   写同步的代码<br /> * 3.调用unlock（）方法，释放锁<br /> * <br /> * wait，notify等方法在1.5之前是直接与对象（锁）绑定在一起，1.5之后，将他们也面向对象了，被放在了Condition接口中，<br /> * 但是还是要与锁进行绑定，所以可以进行等待等操作的Condition接口对象是通过调用锁对象的 newCondition()方法得到的<br /> */<br /><br />//线程的停止  stop  替代:  自动停止  ,通过interrupt(中断)<br /><br />//守护线程：可以看成后台线程，依赖于前台线程，当前台线程全部结束时，即使后台线程的任务代码没有执行完成，也会立刻结束<br /><br />//join方法：加入运行 <br /><br />/*<br /> * IO（Input，Output）流：处理设备之间的数据传输<br /> * <br /> * 根据操作的方式分类：输入流和输出流<br /> * <br /> * 还可以根据操作数据的类型分类：字节流和字符流<br /> * <br /> * 字节流：可以操作任何类型的数据实现输入和输出       音频，视频，文本文件，图片<br /> * 字符流：只能操作文本文件这种类型的数据的输入和输出， 在字节流的基础上融入了编码，方便文本的输入和输出<br /> * <br /> * 字节流的两个父类<br /> * 字节输入流的父类: InputStream<br />       字节输出流的父类： OutputStream<br /><br />       字符流：两个父类<br /><br />       字符输入流的父类：Reader<br />       字符输出流的父类：Writer<br />       <br />       输入输出参考物是内存<br />       <br />       设备：键盘，硬盘，内存，网络<br />       <br />       以硬盘为例学习输入和输出<br /> */<br /><br />//向文本文件中写入数据<br /><br />//如果文件路径错误，<br />			//会报异常FileNotFoundException（系统找不到指定的路径）,此时与文件管理的输出流对象也会创建失败<br /><br />//文件的续写：接着文件中原来的内容写 <br />//public FileWriter(File file,  boolean append)   <br />//根据给定的 File 对象构造一个 FileWriter 对象。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。<br /><br />/*<br /> * <br /> * 输入   <br /> * //将数据从文本文件中读出  FileReader<br />读单行<br /> */<br /><br />读多行<br /><br /><br />//复制一个java文件<br />//使用字符读取流读取被复制的文件，每次读出来的数据写入到新的文件<br /><br />//复制一个java文件<br />//一次读取多个字符<br /><br />/*<br /> * 字符串的缓冲区:缓冲区是为了提高效率,只具备提高效率的功能,不具备读或写的功能,所以在使用的时候必须结合输入流或者输出流<br /> * 我们称之为缓冲流,可以将他称之为高速的小车<br /> * <br /> * BufferredReader<br /> * BufferredWriter<br /> */<br /><br />//BufferredReader  只是能提高输入流对象的工作效率，不能实现输入<br /><br />//缓冲流的输入输出例子<br /><br />//LineNumberReader---- 是BufferedReader的子类<br /><br />自定义BufferredReader<br /><br />装饰设计模式<br /><br />/*<br /> * 字符流：<br /> * 输入流：Reader<br /> * 读一个字符read  <br /> * 读多个字符 read(arr)<br /> * <br /> * 输出流：Writer<br /> * write<br /> * close<br /> * fluse<br /> *<br /> * <br /> * 缓冲输入流：BufferedReader<br /> * 读一行文本  readLine()<br /> * 缓冲输出流：BufferedWriter<br /> *  newLine<br /> *  <br /> *  字节流<br /> *  输入流：InputStream<br /> *  输出流：OutputStream<br /> *  <br /> */<br /><br /> * 复制图片<br /> */<br /><br />//通过缓冲字节输入输出流实现图片的复制<br /><br />/*<br /> * 标准输入流:此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。<br /> * 标准输出流<br /> */<br /><br />/*<br />*<br /> * 刚才的功能（循环读取键盘里面的数据），与BufferedReader方法的readLine很相似<br /> * <br /> * 那如果可以使用readLine方法实现刚才的功能就会非常简单<br /> * <br /> * 分析<br /> * System.in  是字节流<br /> * BufferedReader 字符流<br /> * <br /> * 转换流:将字节流转成字符流<br /> * InputStreamReader  输入转换流<br /> * OutputStreamWriter 输出转换流<br /> */<br /><br />/*<br /> * 输入:键盘<br /> * 目的:控制台<br /> * <br /> * 输入:键盘<br /> * 目的:文件    字符流<br /> * <br /> * 输入:文件<br /> * 目的:控制台<br /> * <br /> * 输入:文件<br /> * 输出:文件<br /> */<br /><br />//修改标准输入输出流的来源<br /><br />/**<br /> * File类:用来操作文件和路径(目录的)<br /> * * 生成文件类对象<br /> * 创建文件<br /> * 创建路径<br /> * 创建多层路径<br /> * <br /> * 判断是否是文件<br /> * 判断是否是路径<br /> * 判断是否隐藏<br /> * 输出最后修改文件的时间<br />new SimpleDateFormat("yyyy-MM-dd E HH:mm:ss").format(new Date(file.lastModified()))<br /> */<br /><br />/*<br /> * 获取目录<br /> */<br />//获取根目录<br />//获取当前目录下的目录和文件,得到是字符串形式<br />//获取全路径<br /><br />/*<br /> * 递归:<br /> * //递归:就是自己调用自己,实现功能<br />//注意点:1.要给一个出口,否则死循环   2.循环次数不要太多,否则占用内存过多,死机<br /> */<br /><br />/*<br /> * 递归例子<br /> * <br /> */<br /><br />/*<br /> * PrintStream: 打印流 除了拥有输出流的基本功能之外,还额外拥有自己的功能----打印<br /> *   支持打印:可以输出的设备:1.File类型的文件<br /> * 	2.字符串类型的文件<br /> * 	3.字节输出流<br /> */<br /><br /><br />//要求:获取当前目录下的所有文件内容<br />//求给定值内偶数的积与奇数的积的差<br /><br /><br />/*<br /> * Properties:是一个Map集合,存储的是属性,属性是以键值对的方式存在,且键值都必须是字符串类型的,<br /> *                 所以他没有使用泛型<br />		           //因为他可以跟流结合使用,所以在讲流的同时将他<br /> */<br /><br />/*<br /> * PrintStream:字节打印流<br /> * <br /> * PrintWriter:字符打印流<br /> * 拥有打印功能<br /> * <br /> * 支持打印:可以输出的设备:File类型的文件<br /> * 2.字节流<br /> * 3.字符流<br /> * 4.字符串类型的文件<br /> */<br /><br />/*<br /> * 序列流:<br /> * 序列流SequenceInputStream:可以连续打印多个流<br /> */<br /><br />/*<br /> * 对象的序列化:将对象进行更加长久的存储<br /> * //所有序列化的对象都要实现Serializable接口,虽然这个接口没有方法,但是是一个规则<br /> * <br /> * 使用系统默认的serialVersionUID与使用自定义的区别?<br /> * 系统的序列化对象一旦进行了序列化就不能改变<br /> * 自定义的可以做稍微的改变<br /> * <br /> * 实现序列化的过程<br />    * 1.合理使用ObjectInputStream和ObjectOutputStream,他们都需要给构造方法传递字节输入流或输出流对象<br />   * 2.在这个过程中,只要保证serialVersionUID值不变,就能成功<br />   * 4.所有进行序列化和反序列化的类都要实现Serializable接口<br /> */<br /><br />/*<br /> * 随机访问:<br /> * RandomAccessFile:不属于IO体系,只能操作文件,内部既有字节输出流,又有字节输入流,通过制定读写的方式区分读写<br /> * 					内部有一个字节数组,可以通过指针设置,所以可以随机访问,需要操作哪个字节,就将指针指向哪个字节<br /> * 作用:可以应用于下载时的断点续传<br /> */<br /><br />/*<br /> * 数据流<br /> * DataInputStream<br /> * DataOutputStream<br /> * 允许从底层直接获取--效率高<br /> */<br /><br />/*<br /> * 内存流    ByteArrayInputStream  写入内存,在内部有 一个内部的数组,数据被放在里面<br /> * 		   ByteArrayOutputSteam 将数据取出,放在字节数组中<br /> */<br /><br />/*转换流的编码问题<br /> * 编码:将字符串转化成byte序列的过程<br /> * 编码错误:在读入与写出的过程中使用的编码格式不同,造成编码错误<br /> * <br /> */<br /><br />/*<br /> * 编码:发电报   "你好,请给bigData班每人发10000元"  ----编码 ------     字节序列  <br /> *  字节序列 ------解码-------     字符串<br /> * byte[] getBytes() <br />使用平台的默认字符集将此 String 编码为 byte 序列，<br />并将结果存储到一个新的 byte 数组中。 <br /><br />byte[] getBytes(Charset charset) <br />使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 <br /><br />String(byte[] bytes) <br />通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。<br /><br />String(byte[] bytes, Charset charset) <br />通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。<br /><br />//这里使用gbk编码,使用ISO8859-1解码,编码解码不统一,出错<br />		//编码错了,解码也会错<br />		//编码正确,解码不对,可以先利用解码时的编码格式进行再编码,然后使用原来编码时的编码格式再解码<br />		//作用:后面使用tomcat服务器时,使用的欧洲编码.经常要再编码再解码<br /> */<br /><br />/*<br /> *  * 网络知识:网络通信三要素:<br /> * 1网络协议:http,https,UDP,TCP等<br /> *   UDP:面向无连接的,不安全,速度快,发送的是数据包<br /> *   TCP:面向连接的,安全,速度要慢,发送的是流<br /> * 2.IP地址 :127.0.0.1本地保留地址(访问自己的电脑)     对应的类:InetAddressc   192.123.23.2  255.255.255.255<br /> * 3.端口号:0-65535(只能是这个范围)  两边的端口号要一致<br /> * <br /> * 使用Socket(套接字)完成通信(干活)<br /> * <br /> * 应用层<br />与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。<br />例如，一个没有通信功能的字处理程序就不能执行通信的代码，<br />从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个<br />传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。<br />示例：TELNET，HTTP，FTP，NFS，SMTP等。<br />表示层<br />这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制<br />或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。<br />如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后<br />发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。<br />会话层<br />它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，<br />以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，<br />在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。<br />传输层<br />这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同<br />应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。<br />示例：TCP，UDP，SPX。<br />网络层<br />这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了<br />路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，<br />网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。<br />数据链路层<br />它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。<br />物理层<br />OSI的物理层规范是有关传输介质的特性标准，这些规范通常也参考了其他组织制定的标准。<br />连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。<br />物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。<br /> */<br /> */<br /><br />/*<br /> * 编码:发电报   "你好,请给bigData班每人发10000元"  ----编码 ------     字节序列  <br /> *  字节序列 ------解码-------     字符串<br /> * byte[] getBytes() <br />使用平台的默认字符集将此 String 编码为 byte 序列，<br />并将结果存储到一个新的 byte 数组中。 <br /><br />byte[] getBytes(Charset charset) <br />使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 <br /><br />String(byte[] bytes) <br />通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。<br /><br />String(byte[] bytes, Charset charset) <br />通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。<br /><br />//这里使用gbk编码,使用ISO8859-1解码,编码解码不统一,出错<br />		//编码错了,解码也会错<br />		//编码正确,解码不对,可以先利用解码时的编码格式进行再编码,然后使用原来编码时的编码格式再解码<br />		//作用:后面使用tomcat服务器时,使用的欧洲编码.经常要再编码再解码<br /> */<br /><br />/*<br /> * 比较 UDP,TCP<br /> * UDP:面向无连接的,不安全,速度快,发送的是数据包<br /> * TCP:面向连接的,安全,速度要慢,发送的是流<br /> * <br /> * 使用套接字(socket)完成通信<br /> * <br /> * InetAddress:ip地址类<br /> * <br /> */<br /><br />/*<br /> * 用udp协议实现数据的发送与接收<br /> * 数据的发送<br /> * <br /> * DatagramSocket:此类表示用来发送和接收数据包的套接字<br /> * DatagramPacket:此类表示数据报包<br /> * <br /> * 1.创建socket端点对象<br /> * 2.准备数据,封装包<br /> * 3.发送数据,通过send方法<br /> * <br /> */<br /><br />/*<br /> * 接收数据<br /> * <br /> * 1.创建socket端点对象,并绑定端口<br /> * 2.创建包对象,创建空数组准备接收数据<br /> * 3.接收数据<br /> */<br /><br />/*<br /> * 发送方:实现随时写随时发<br /> */<br /><br />/*<br /> * 接收方<br /> */<br /><br />/*<br /> * TCP的使用<br /> * <br /> * 我们可以这样理解:在客户端与服务器端进行数据传输时,对于客户端来说要进行输出和输入,<br /> * 而在Socket里面既有输出流又有输出流.在进行数据传输时,是将数据保存到Socket对象里面<br /> * 将socket对象传到服务器端,这时客户端和服务端在进行操作的时候相当于都有了同一个socket对象,<br /> * 我们便可以通过操作他实现数据的传输<br /> *但其实这个通道就是socket对象<br /> */<br />//客户端<br /><br />/*<br /> * 服务器端<br /> */<br /><br /><br />/* 实现一个大写转换服务器：客户端接收键盘输入的小写字符串发送给服务器端<br />*               服务器端把接收到的小写字符串转成大写再发给客户端<br />*/<br /><br />客户端<br /><br />服务器端<br /><br />/*<br /> * 例子:上传文件<br /> * 分析:<br /> * 1.客户端<br /> * 从文件读数据,发送到服务器端<br /> * 2.服务器端<br /> * 将客户端发送过来的数据写入到一个服务器中的文件中<br /> * 发送会客户端一个上传成功的消息<br /> */<br /><br />客户端<br /><br />服务器端<br /><br />//上传图片----客户端设置<br /><br />服务器端</div></div>
</body></html>